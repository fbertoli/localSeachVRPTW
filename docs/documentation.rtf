{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Class Solution\
- start_po\
\
FEASIBILITY VARS\
There are different vars to check feasibility\
feasibility_to_path indicate the feasibility of reaching a path. They start as true. IF they are set at false they maintain that value until they are re-set.\
\
feasibility_to_path_1_ vars are re-set when k_ is decreased, re-set and checked when i_ is decreased and checked only j_ is increased.\
feasibility_to_path_2_ vars are re-set when r i_ is decreased, re-set and when k_ is decreased and  checked only when l_ is increase\
\
feasibility_route_2_ works the opposite way. Example: feasibility_route_2_ is set at true when j_, k_, i_ is modified. If at a certain l_ the new route_2 is feasibly, increasing l_ does not destroy is feasibility.\
\
start_l_index_[i_+1][j_][k_] serves as an indicator to start checking l_. The idea is: if the path 0,..,k_,i+1,..,j_,l_+1 is not feasible then when we will increase j_ or decrease i_ the same value of l_ will still be infeasible. \
\
feasibility_route_1_ serves only in the finals checks to avoid checking route 1 twice when we are trying to reverse path 1 (as route in not involve).}